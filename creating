from tkinter import *
from random import *
import random
from tkinter import messagebox

# forced blocked item : ðŸš«

# var, list, etc...
game_map_pp, game_map_mp, game_map_pm, game_map_mm = [], [], [], []
colors = ["â¬œ", "ðŸŸ¥", "ðŸŸ§","ðŸŸ¨","ðŸŸ©","ðŸŸ¦","ðŸŸ«","â¬›"] # ðŸŸª
color_dictionary = {"ðŸŸ¥":"#eb4034", "â¬œ":"#ffffff", "ðŸŸ§":"#f58742", "ðŸŸ¨":"#f5f242", "ðŸŸ©":"#90f542", "ðŸŸ¦":"#4287f5", "ðŸŸª":"#c242f5", "ðŸŸ«":"#7a4316", "â¬›":"#000000"}
lava_biome = ["ðŸŸ¥" ,"ðŸŸ§"]
pale_radio_biome = ["â¬œ", "â¬›"]
desert_biome = ["ðŸŸ¨"]
plain_biome = ["ðŸŸ©"]
ocean_biome = ["ðŸŸ¦"]
muddy_world = ["ðŸŸ«"]
biomes = ["lava", "plain", "desert", "pale radio", "ocean", "mud"] # GLITCH ISLAND
biome_match = {'â¬œ':"pale radio", 'â¬›':"pale radio", 'ðŸŸ§':'lava', 'ðŸŸ¥':'lava', 'ðŸŸ©':'plain', 'ðŸŸ¦':'ocean', 'ðŸŸ«':'mud', 'ðŸŸ¨':'desert'}
start_map = []
x, y = 0, 0

# IndexError : OutOfBound

# Define

def BringSquare(camX, camY) :
    if (camX>=0) :
        if (camY>=0) :
            return game_map_pp[camX][camY]
        else :
            return game_map_mp[camX][-1*camY]
    else :
        if (camY>=0) :
            return game_map_pm[-1*camX][camY]
        else :
            return game_map_mm[-1*camX][-1*camY]

def randomBlock(biome) :
    if biome == "ocean" :
        return random.choice(ocean_biome)
    if biome == "desert" :
        return (random.choice(desert_biome))
    if biome == "lava" :
        return (random.choice(lava_biome))
    if biome == "mud" :
        return (random.choice(muddy_world))
    if biome == "plain" :
        return (random.choice(plain_biome))
    if biome == "pale radio" :
        return (random.choice(pale_radio_biome))

def RandomSquare(direct, biome) :
    if (direct=='L') :
        lR = random.randint(1, 3)
        if (lR<=3) :
            return randomBlock(biome)
        else :
            return random.choice(colors)
    if (direct=='R') :
        lR = random.randint(1, 4)
        if (lR<=2) :
            return randomBlock(biome)
        else :
            return random.choice(colors)
    if (direct=='U') :
        lR = random.randint(1, 5)
        if (lR<=5) :
            return randomBlock(biome)
        else :
            return random.choice(colors)
    if (direct=='D') :
        lR = random.randint(1, 7)
        if (lR<=0) :
            return randomBlock(biome)
        else :
            return random.choice(colors)

def LoadingWorld(X, Y) :
    for i in range(-2, 3) :
        if (X+i>=0) :
            if Y+2>=0 :
                try :
                    print(game_map_pp[X+i][Y+2])
                    print(game_map_pp[X+i][Y+3])
                except IndexError :
                    game_map_pp[X+i].append('â¬œ')
            if Y-2<=0 :
                try :
                    game_map_mp[X+i][abs(Y-2)]
                    game_map_mp[X+i][abs(Y-3)]
                except IndexError :
                    game_map_mp[X+i].append('â¬œ')
        if (X+i<=0) :
            if Y+2>=0 :
                try :
                    game_map_pm[abs(X+i)][Y+2]
                    game_map_pm[abs(X+i)][Y+3]
                except IndexError :
                    game_map_pm[X+i].append('â¬œ')

            if Y-2<=0 :
                try :
                    game_map_mm[abs(X+i)][abs(Y-2)]
                    game_map_mm[abs(X+i)][abs(Y-3)]
                except IndexError :
                    game_map_mm[X+i].append('â¬œ')

    if Y+2>=0 :
        if X+2>=0 : 
            if (len(game_map_pp[X+3])<Y+3) :
                for i in range(Y+3-len(game_map_pp[X+3])) :
                    game_map_pp[X+3].append(RandomSquare('L', biome_match[game_map_pp[X+2][Y+i]]))
        if X-2<=0 :
            if (len(game_map_pm[abs(X-3)])<Y+3) :
                for i in range(Y+3-len(game_map_pm[abs(X-3)])) :
                    game_map_pm[abs(X-3)].append(RandomSquare('R', biome_match[game_map_pm[abs(X-2)][Y+i]])) # 

    if Y-2<=0 :
        if X+2>=0 :
            if (len(game_map_mp[X+3])<abs(Y-3)) :
                for i in range(abs(Y-3)-len(game_map_mp[X+3])) :
                    game_map_mp[X+3].append(RandomSquare('L', biome_match[game_map_mp[X+2][abs(Y-i)]])) # 
        if X-2<=0 :
            if (len(game_map_mm[abs(X-3)])<abs(Y-3)) :
                for i in range(abs(Y-3)-len(game_map_mm[abs(X-3)])) :
                    game_map_mm[abs(X-3)].append(RandomSquare('R', biome_match[game_map_mm[abs(X-2)][abs(Y-i)]])) # 


def SettingWorld() :
    global x, y
    
    if (x+3>=len(game_map_pp)) :
        game_map_pp.append([])

    if (x+3>=len(game_map_mp)) :
        game_map_mp.append([])

    if (abs(x-3)>=len(game_map_pm)) :
        game_map_pm.append([])

    if (abs(x-3)>=len(game_map_mm)) :
        game_map_mm.append([])
    
    LoadingWorld(x, y)

def SetDisplay(X, Y) :
    for j in range(5) :
        for i in range(5) :
            canvas.create_rectangle(i*100, j*100, i*100+100, j*100+100, fill=color_dictionary[BringSquare(2-i+X, 2-j+Y)], outline=color_dictionary[BringSquare(2-i+X, 2-j+Y)])

def move(event) :
    global x, y

    if (event.keysym=="Up") :
        y+=1
        SetDisplay(x, y)
        SettingWorld()
    
    if (event.keysym=="Down") :
        y-=1
        SetDisplay(x, y)
        SettingWorld()

    if (event.keysym=="Right") :
        x-=1
        SetDisplay(x, y)
        SettingWorld()
    
    if (event.keysym=="Left") :
        x+=1
        SetDisplay(x, y)
        SettingWorld()

# starting settings

start_biome = random.choice(biomes)

for i in range(5) :
    start_map.append([])
    for j in range(5) :
        if start_biome == "ocean" :
            start_map[i].append(random.choice(ocean_biome))
        if start_biome == "desert" :
            start_map[i].append(random.choice(desert_biome))
        if start_biome == "lava" :
            start_map[i].append(random.choice(lava_biome))
        if start_biome == "mud" :
            start_map[i].append(random.choice(muddy_world))
        if start_biome == "plain" :
            start_map[i].append(random.choice(plain_biome))
        if start_biome == "pale radio" :
            start_map[i].append(random.choice(pale_radio_biome))

for i in range(3) :
    game_map_pp.append([])
    for j in range(3) :
        game_map_pp[i].append(start_map[2-i][2-j])

for i in range(3) :
    game_map_pm.append([])
    for j in range(3) :
        game_map_pm[i].append(start_map[2-i][2+j])

for i in range(3) :
    game_map_mp.append([])
    for j in range(3) :
        game_map_mp[i].append(start_map[2+i][2-j])

for i in range(3) :
    game_map_mm.append([])
    for j in range(3) :
        game_map_mm[i].append(start_map[2+i][2+j])

SettingWorld()

for i in range(3) :
    for j in range(3) :
        print(game_map_pp[2-i][2-j], end="")
    print("")

print("")

for i in range(3) :
    for j in range(3) :
        print(game_map_pm[2-i][j], end="")
    print("")

print("")

for i in range(3) :
    for j in range(3) :
        print(game_map_mp[i][2-j], end="")
    print("")

print("")

for i in range(3) :
    for j in range(3) :
        print(game_map_mm[i][j], end="")
    print("")

print("")

for i in range(4) :
    print(game_map_pp[i])

for i in range(4) :
    print(game_map_pm[i])

for i in range(4) :
    print(game_map_mp[i])

for i in range(4) :
    print(game_map_mm[i])

# tkinter PART

win = Tk()

win.title("BRUH")

canvas = Canvas(win, bg = "#ffffff", width = 500, height = 500)

SetDisplay(x, y)

print(BringSquare(0, 1))

canvas.bind_all("<KeyPress-Up>", move)
canvas.bind_all("<KeyPress-Down>", move)
canvas.bind_all("<KeyPress-Right>", move)
canvas.bind_all("<KeyPress-Left>", move)

canvas.grid(row=0, column=1)

win.mainloop()
